#! /usr/bin/perl -w
#
# simple script to switch the keyboard language
# (c) 2014 jw@owncloud.om

my $sysconffile = '/etc/sysconfig/keyboard';
my $mapdir = '/usr/share/kbd/keymaps/i386';

my $version = '1.3';

my $what = shift || '-h';


my $v = slurp_sysconf($sysconffile);
my $m = find_maps();

my $l = {
  'american' => 'us.map',
  'british'  => 'uk.map',
  'dutch'    => 'nl.map',
  'french'   => 'fr-latin1.map',
  'german'   => 'de-latin1-nodeadkeys.map',
  'italian'  => 'it.map',
  'spanish'  => 'es.map',
};

for my $k (keys %$l)
  {
    # zap non-installed languages from our pretty printed list.
    delete $l->{$k} unless $m->{$l->{$k}} or $m->{"$l->{$k}.gz"};
  }

my $oldkeytable = $v->{KEYTABLE} || '<unknown>';
$oldkeytable =~ s{.map.*$}{.map};

if ($what eq '-h' or $what eq '/h')
  {
    print qq{kbd Version $version

Usage: $0 [option] [mapping]

Available options are:
  -l          list typical language mappings.
  -c [PROMPT] choose a keymap -l style, via STDIN/STDOUT
  -a          list all maps
  -q          only print the current keymap name
  -h          print this usage

Specify as a mapping either a language name (seen with -l)
or a mapping name (seen with -a). For a mapping name, add a .map suffix.

Current keymap: $oldkeytable
};
    exit 0;
  }
elsif ($what eq '-q' or $what eq '/q')
  {
    print "$oldkeytable\n";
    exit 0;
  }
elsif ($what eq '-c' or $what eq '/c')
  {
    die "STDIN must be on a terminal\n" unless -t STDIN;
    die "STDOUT must be on a terminal\n" unless -t STDOUT;
    my $default = '';
    my @idx2name;
    my $idx = 1;
    my $prompt = shift || "\nEnter language number: [%s]> ";
    for my $k (sort keys %$l)
      {
        my $sel = ' ';
	if ($l->{$k} eq $oldkeytable)
	  {
	    $sel = '*';
	    $default = $idx;
	  }
	$idx2name[$idx] = $k;
        printf "%2d:%s %-10s %s\n", $idx++, $sel, $k, $l->{$k};
      }

    $|++;
    printf $prompt, $default;
    $|--;
    my $input = <STDIN>;
    chomp $input;
    exit 0 if $input =~ m{^\s*$};

    if ($input =~ m{^(\d+)})
      {
        $what = $idx2name[$1] || $input;
      }
    else
      {
        $what = $input;
      }
  }
elsif ($what eq '-l' or $what eq '/l')
  {
    for my $k (sort keys %$l)
      {
        printf "%-10s %s\n",  $k, $l->{$k};
      }
    exit 0;
  }
elsif ($what eq '-a' or $what eq '-m' or $what eq '/a' or $what eq '/m')
  { 
    my @k = map { $1 if /(.*).map(.gz)?$/ } sort keys %$m;
    print "current keymap: $v->{KEYTABLE}\n";
    print "available keymaps: @k\n";
    print "\n\nuse '$0 MAPNAME' to change.\n";
    exit 0;
  }

$what = $l->{$what} if $l->{$what};

$what = "$what.gz"     if $m->{"$what.gz"};
$what = "$what.map"    if $m->{"$what.map"};
$what = "$what.map.gz" if $m->{"$what.map.gz"};

die "$what: keymap not found.\n Try $0 -h\n" unless $m->{$what};

write_sysconf($sysconffile, { 'KEYTABLE' => $what } );
# system("kbd_mode -u");		# switch to unicode. Should be the default anyway.
system("loadkeys $what");	# now set the keymap.

# FIXME: is that all?
# mayb also do: systemctl restart kbd.service 

print STDERR "\nNOTE: kbd is a console tool. It does not affect terminal windows.\n"
  if $ENV{XDG_SESSION_ID} || $ENV{XDG_SEAT} || $ENV{XDG_VTNR};

exit 0;
###################################################################

sub find_maps
{
  my $maps;

  opendir DIR, $mapdir or die "$0: cannot readdir $mapdir: !$\n";
  my @d = grep { -d "$mapdir/$_" && !/^\./ } readdir DIR;
  closedir DIR;
  for my $d (@d)
    {
      opendir DIR, "$mapdir/$d" or die "$0: cannot readdir $mapdir/$d: !$\n";
      my @f = grep { /\.map(.gz)?$/ } readdir DIR;
      closedir DIR;
      for my $f (@f)
        {
          $maps->{$f} = "$d/$f";
        }
    }
  return $maps;
}

sub slurp_sysconf
{
  my ($file) = @_;
  
  my $vals;
  open my $fd, "<", $file or die "$0: cannot read config file $file: $!\n";
  while (defined(my $line = <$fd>))
    {
      chomp $line;
      $vals->{$1} = $2 if $line =~ m{^([A-Z_]+)\s*=\s*"(.*)"};
    }
  close $fd; 
  return $vals;
}

sub write_sysconf
{
  my ($file, $vals) = @_;
  
  my @sysconf = ();
  open my $fd, "<", $file or die "$0: cannot read config file $file: $!\n";
  while (defined(my $line = <$fd>))
    {
      chomp $line;
      push @sysconf, $line;
    }
  close $fd; 
  open $fd, ">", $file or die "$0: cannot write config file $file: $!\n";
  for my $line (@sysconf)
    {
      if ($line =~ m{^([A-Z_]+)\s*=\s*"(.*)"})
        {
           my ($keyword,$value) = ($1,$2);
           if (defined $vals->{$keyword})
             {
               $line =~ s{\Q$value\E}{$vals->{$keyword}};
             }
        }
      print $fd "$line\n";
    }
  close $fd or die "$0: could not write config file $file: $!\n";
}
